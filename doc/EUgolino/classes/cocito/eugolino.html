<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>EUgolino.classes.cocito.eugolino API documentation</title>
<meta name="description" content="EUgolino
file name: eugolino.py
author: Lorenzo Radice
license: European Union Public Licence v. 1.2.">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>EUgolino.classes.cocito.eugolino</code></h1>
</header>
<section id="section-intro">
<p>EUgolino<br>
file name: eugolino.py<br>
author: Lorenzo Radice<br>
license: European Union Public Licence v. 1.2.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="EUgolino.classes.cocito.eugolino.DownloadCandidate"><code class="flex name class">
<span>class <span class="ident">DownloadCandidate</span></span>
<span>(</span><span>url: str, filename: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DownloadCandidate:
    &#34;&#34;&#34;
    A class representing a download candidate with a URL and a filename.
    &#34;&#34;&#34;
    url: str
    &#34;&#34;&#34;The URL of the file.&#34;&#34;&#34;
    name: str
    &#34;&#34;&#34;The name of the file.&#34;&#34;&#34;
    filename: str
    &#34;&#34;&#34;The filename of the file.&#34;&#34;&#34;

    def __init__(self, url: str, filename: str) -&gt; None:
        &#34;&#34;&#34;
        Constructor
        
        Initializes an instance of DownloadCandidate.

        Args:
            url (str): The URL of the file.
            filename (str): The name of the file.

        Returns:
            None
        &#34;&#34;&#34;
        self.url = url
        self.name = filename
        self.filename = filename + &#34;.pdf&#34;

    @staticmethod    
    def make_candidate(line: str) -&gt; &#34;DownloadCandidate&#34;:
        &#34;&#34;&#34;
        Create a DownloadCandidate object based on the given line.

        Args:
            line (str): The input line containing the name and URL separated by a comma.

        Returns:
            DownloadCandidate: The created DownloadCandidate object.

        Raises:
            None

        &#34;&#34;&#34;
        # Initialize the candidate
        candite: DownloadCandidate = None
        # Initialize the Log Manager
        log = LogManager()
        try:
            # Remove the newline character
            line = line.strip()
            # Split the line
            name = line.split(&#34;,&#34;)[0]
            url = line.split(&#34;,&#34;)[1]
            # Check if the name and URL are not empty
            if name != &#34;&#34; and url != &#34;&#34;:
                # Create the candidate
                candite = DownloadCandidate(url, name)
            else:
                log.print_err(&#34;Error line non parsed:\t&#34; + line)
        except:
            log.print_err(&#34;Error line:\t&#34; + line)
        # Return the candidate
        return candite
    
    def print_candidate(self) -&gt; str:
            &#34;&#34;&#34;
            Returns a string representation of the candidate&#39;s name and URL.
            It works for CSV format.

            Returns:
                A string in the format &#34;&lt;name&gt;,&lt;url&gt;&#34; representing the candidate&#39;s name and URL.
            &#34;&#34;&#34;
            return self.name + &#34;,&#34; + self.url

    def __str__(self) -&gt; str:
        return &#34;Name: &#34; + self.name + &#34;\nFilename: &#34; + self.filename + &#34;\nURL: &#34; + self.url</code></pre>
</details>
<div class="desc"><p>A class representing a download candidate with a URL and a filename.</p>
<p>Constructor</p>
<p>Initializes an instance of DownloadCandidate.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL of the file.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<h3>Class variables</h3>
<dl>
<dt id="EUgolino.classes.cocito.eugolino.DownloadCandidate.filename"><code class="name">var <span class="ident">filename</span> : str</code></dt>
<dd>
<div class="desc"><p>The filename of the file.</p></div>
</dd>
<dt id="EUgolino.classes.cocito.eugolino.DownloadCandidate.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>The name of the file.</p></div>
</dd>
<dt id="EUgolino.classes.cocito.eugolino.DownloadCandidate.url"><code class="name">var <span class="ident">url</span> : str</code></dt>
<dd>
<div class="desc"><p>The URL of the file.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="EUgolino.classes.cocito.eugolino.DownloadCandidate.make_candidate"><code class="name flex">
<span>def <span class="ident">make_candidate</span></span>(<span>line: str) ‑> <a title="EUgolino.classes.cocito.eugolino.DownloadCandidate" href="#EUgolino.classes.cocito.eugolino.DownloadCandidate">DownloadCandidate</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod    
def make_candidate(line: str) -&gt; &#34;DownloadCandidate&#34;:
    &#34;&#34;&#34;
    Create a DownloadCandidate object based on the given line.

    Args:
        line (str): The input line containing the name and URL separated by a comma.

    Returns:
        DownloadCandidate: The created DownloadCandidate object.

    Raises:
        None

    &#34;&#34;&#34;
    # Initialize the candidate
    candite: DownloadCandidate = None
    # Initialize the Log Manager
    log = LogManager()
    try:
        # Remove the newline character
        line = line.strip()
        # Split the line
        name = line.split(&#34;,&#34;)[0]
        url = line.split(&#34;,&#34;)[1]
        # Check if the name and URL are not empty
        if name != &#34;&#34; and url != &#34;&#34;:
            # Create the candidate
            candite = DownloadCandidate(url, name)
        else:
            log.print_err(&#34;Error line non parsed:\t&#34; + line)
    except:
        log.print_err(&#34;Error line:\t&#34; + line)
    # Return the candidate
    return candite</code></pre>
</details>
<div class="desc"><p>Create a DownloadCandidate object based on the given line.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>line</code></strong> :&ensp;<code>str</code></dt>
<dd>The input line containing the name and URL separated by a comma.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="EUgolino.classes.cocito.eugolino.DownloadCandidate" href="#EUgolino.classes.cocito.eugolino.DownloadCandidate">DownloadCandidate</a></code></dt>
<dd>The created DownloadCandidate object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>None</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="EUgolino.classes.cocito.eugolino.DownloadCandidate.print_candidate"><code class="name flex">
<span>def <span class="ident">print_candidate</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_candidate(self) -&gt; str:
        &#34;&#34;&#34;
        Returns a string representation of the candidate&#39;s name and URL.
        It works for CSV format.

        Returns:
            A string in the format &#34;&lt;name&gt;,&lt;url&gt;&#34; representing the candidate&#39;s name and URL.
        &#34;&#34;&#34;
        return self.name + &#34;,&#34; + self.url</code></pre>
</details>
<div class="desc"><p>Returns a string representation of the candidate's name and URL.
It works for CSV format.</p>
<h2 id="returns">Returns</h2>
<p>A string in the format "<name>,<url>" representing the candidate's name and URL.</p></div>
</dd>
</dl>
</dd>
<dt id="EUgolino.classes.cocito.eugolino.EUgolino"><code class="flex name class">
<span>class <span class="ident">EUgolino</span></span>
<span>(</span><span>file_in: str,<br>candidates: list[<a title="EUgolino.classes.cocito.eugolino.DownloadCandidate" href="#EUgolino.classes.cocito.eugolino.DownloadCandidate">DownloadCandidate</a>] = None,<br>max_downloads: int = None,<br>starting_point: int = 0,<br>destination: str = None,<br>not_downloaded_file: str = None,<br>output: classes.log_manager.LogManager = None,<br>name: str = 'EUgolino')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EUgolino(threading.Thread):
    &#34;&#34;&#34;
    EUgolino is a class which allow to download PDF files from a list of URLs.

    It was specifically designed to download papers from the European Union DataBase.
    As the Conte Ugolino in Dante&#39;s Inferno, it is a greedy downloader.
    As Ugolino della Gherardesca eats from the head of his enemy, 
    EUgolino feeds himself with the knowledge of scientific papers.
    &#34;&#34;&#34;
    file_in: str
    &#34;&#34;&#34;Input file containing the list of URLs.&#34;&#34;&#34;
    candidates: list[DownloadCandidate] = []
    &#34;&#34;&#34;List of download candidates.&#34;&#34;&#34;
    max_downloads: int = -1
    &#34;&#34;&#34;Maximum number of downloads.&#34;&#34;&#34;
    starting_point: int = 0
    &#34;&#34;&#34;Starting point for the download.&#34;&#34;&#34;
    destination: str = &#34;pdf/&#34;
    &#34;&#34;&#34;Destination folder for downloaded files.&#34;&#34;&#34;
    current: DownloadCandidate = None
    &#34;&#34;&#34;Current download candidate.&#34;&#34;&#34;
    downloaded: int = 0
    &#34;&#34;&#34;Number of downloaded files.&#34;&#34;&#34;
    not_downloaded_files:str = &#34;not_downloaded.txt&#34;
    &#34;&#34;&#34;File to store the list of files that were not downloaded.&#34;&#34;&#34;
    output:LogManager = LogManager()
    &#34;&#34;&#34;Log Manager for logging.&#34;&#34;&#34;

    def __init__(self, file_in: str, candidates: list[DownloadCandidate] = None, max_downloads: int = None, starting_point: int = 0, destination: str = None, not_downloaded_file: str = None, output: LogManager = None, name: str = &#34;EUgolino&#34;) -&gt; None:
        &#34;&#34;&#34;
        Initializes an instance of the EUgolino class.

        Args:
            file_in (str): The input file.
            candidates (list[DownloadCandidate], optional): List of download candidates. Defaults to None.
            max_downloads (int, optional): Maximum number of downloads. Defaults to None.
            starting_point (int, optional): Starting point for the download. Defaults to 0.
            destination (str, optional): Destination directory for downloaded files. Defaults to None.
            not_downloaded_file (str, optional): File to store the list of files that were not downloaded. Defaults to None.
            output (LogManager, optional): LogManager instance for logging. Defaults to None.
        &#34;&#34;&#34;
        self.file_in = file_in
        if candidates is not None:
            self.candidates = candidates
        if max_downloads is not None:
            self.max_downloads = max_downloads
        if destination is not None:
            self.destination = destination
        if not_downloaded_file is not None:
            self.not_downloaded_files = not_downloaded_file
        if output is not None:
            self.output = output
        if self.max_downloads &lt; 0 or starting_point &lt; self.max_downloads:
            self.starting_point = starting_point
        threading.Thread.__init__(self, name=name)

    def __str__(self) -&gt; str:
        out = &#34;Name: &#34; + self.name + &#34;\nInput file: &#34; + self.file_in + &#34;\n&#34; + &#34;Number of urls: &#34; + str(len(self.candidates)) + &#34;\n&#34; + &#34;Destination folder: &#34; + self.destination + &#34;\n&#34; + &#34;Max downloads: &#34; + str(self.max_downloads) + &#34;\n&#34; + &#34;Downloaded: &#34; + str(self.downloaded)
        if self.current is not None:
            out += &#34;\n&#34; + &#34;Current\n&#34; + str(self.current)
        return out
    
    def import_file(self, file:str = None, candites: list[DownloadCandidate] = None) -&gt; int:
        &#34;&#34;&#34;
        Imports a file and processes its contents to create download candidates.

        Args:
            file (str, optional): The path of the file to import. Defaults to None.
            candites (list[DownloadCandidate], optional): The list of existing download candidates. Defaults to None.

        Returns:
            int: The number of errors encountered during the import process.
        &#34;&#34;&#34;
        if file is not None:
            self.file_in = file
        if candites is not None:
            self.candidates = candites
        # Initialize the errors counter
        errors = 0
        # Initialize the candidate
        candite: DownloadCandidate = None
        try:
            # Open the file
            with open(self.file_in, &#39;r&#39;) as f:
                # Read the file line by line
                self.output.print_out(&#34;Importing file: &#34; + self.file_in)
                # Process each line
                for line in f:
                    # Create a candidate
                    candite = DownloadCandidate.make_candidate(line)
                    # Check if the candidate is not None
                    if candite is not None:
                        # Add the candidate to the list
                        self.candidates.append(candite)
                    else:
                        errors += 1
            f.close()
            # ACK message
            self.output.print_out(&#34;File imported&#34;)
        except:
            self.output.print_err(&#34;Error: file\t&#34; + self.file_in + &#34;\tnot imported&#34;)
            errors = -1
        # If the current candidate is None, set it to the first candidate
        if self.candidates != [] and self.current is None:
            self.current = self.candidates[0]
        # Return the number of errors
        return errors
    
    def downloadPDF(self, candidate: DownloadCandidate = None, destination:str = None, not_downloaded_file = None) -&gt; bool:
        &#34;&#34;&#34;
        Downloads a PDF file from a given URL and saves it to the specified destination.

        Args:
            candidate (DownloadCandidate, optional): The download candidate object containing the URL and filename. If not provided, the current candidate will be used. Defaults to None.
            destination (str, optional): The destination directory where the PDF file will be saved. If not provided, the default destination will be used. Defaults to None.
            not_downloaded_file (str, optional): The file path to the log file where the details of the not downloaded files will be recorded. If not provided, the default log file will be used. Defaults to None.

        Returns:
            bool: True if the PDF file was successfully downloaded and saved, False otherwise.
        &#34;&#34;&#34;
        if candidate is not None:
            self.current = candidate
        if destination is not None:  
            self.destination = destination
        if not_downloaded_file is not None:
            self.not_downloaded_files = not_downloaded_file
        full_path = self.destination + self.current.filename
        try:
            # Get the page
            dat = requests.get(url=self.current.url)
            # Get the cookies
            cookies = dat.cookies
            # Parse the page
            soup = BeautifulSoup(dat.text, &#39;html.parser&#39;)
            # Get the script tags
            link = soup.find_all(&#34;script&#34;)
            # Find the link to the pdf
            doc = &#34;&#34;
            # Search for the link
            for l in link:
                # Check if the script tag contains the link to the pdf
                if &#34;window.location&#34; in l.text:
                    # Split the script tag to get the link
                    s = l.text.split(&#34;\&#39;&#34;)
                    # Get the link
                    doc = s[3]
            # Download the pdf
            dat = requests.get(url=doc, cookies=cookies)
            # Save the pdf
            with open(full_path, &#34;wb&#34;) as f:
                f.write(dat.content)
            f.close()
            # Update the downloaded counter
            self.downloaded += 1
            # ACK message
            self.output.print_out(&#34;Downloaded\t&#34; + full_path)
            return True
        except:
            self.output.print_err(&#34;Error\t&#34; + full_path + &#34;\tnot downloaded&#34;)
            try:
                # Save the not downloaded file
                with open(self.not_downloaded_files, &#34;a&#34;) as f:
                    f.write(self.current.print_candidate() + &#34;\n&#34;)
                f.close()
                # Update the input file
                self.file_in = self.not_downloaded_files
            except:
                self.output.print_err(&#34;Error\t&#34; + self.not_downloaded_files + &#34;\tnot updated&#34;)
            self.output.print_out(&#34;FAIL\t\t&#34; + full_path)
            return False

    def download_all(self, candidates: list[DownloadCandidate] = None, destination:str = None, max_downloads:int = None, starting_point:int = None, not_downloaded_files:str = None) -&gt; int:
        &#34;&#34;&#34;
        Downloads all the PDF files from the given list of download candidates.

        Args:
            candidates (list[DownloadCandidate], optional): List of DownloadCandidate objects representing the PDF files to download. If not provided, the previously set candidates will be used. Defaults to None.
            destination (str, optional): The destination folder where the downloaded PDF files will be saved. If not provided, the previously set destination will be used. Defaults to None.
            max_downloads (int, optional): The maximum number of PDF files to download. If not provided, all the candidates will be downloaded. Defaults to None.
            starting_point (int, optional): The starting point for the download. If not provided, the previously set starting point will be used. Defaults to None.
            not_downloaded_files (str, optional): The file path to save the list of files that were not downloaded. If not provided, the previously set file path will be used. Defaults to None.

        Returns:
            int: The number of errors that occurred during the download process.
        &#34;&#34;&#34;
        if candidates is not None:
            self.candidates = candidates
        if destination is not None:
            self.destination = destination
        if max_downloads is not None:   
            self.max_downloads = max_downloads
        if not_downloaded_files is not None:
            self.not_downloaded_files = not_downloaded_files
        if starting_point is not None:
            if self.max_downloads &lt; 0 or starting_point &lt; self.max_downloads:
                self.starting_point = starting_point

        # Initialize the errors counter
        errors = 0

        # Create the destination folder
        os.makedirs(self.destination, exist_ok=True)

        # Get the number of downloads
        num = self.candidates.__len__()

        # Check if the number of downloads is limited
        if self.max_downloads &gt; 0:
            # Limit the number of downloads
            num = min(num, self.max_downloads)

        # Get the number of digits of the length
        fi = self.count_digits(num)
        # Discard the first candidates
        self.candidates = self.candidates[self.starting_point:]
        # Download the PDFs
        for i in range(self.starting_point, num):
            # Get the filename
            self.current = self.candidates.pop(0)

            # Print the progress
            self.output.print_out(&#34;[&#34; + &#34;{:{}}&#34;.format((i+1), fi) + &#39;/&#39; + str(num) + &#34;]:&#34;, end=&#34;\t&#34;)

            # Download the PDF
            if not self.downloadPDF():
                # Update the errors counter
                errors += 1
                # Add the not downloaded file to the list of candidates
                self.candidates.append(self.current)

        return errors
    
    def do_all(self, file_in:str = None, destination:str = None, max_downloads:int = None, not_downloaded_files:str = None) -&gt; int:
        &#34;&#34;&#34;
        Performs all the necessary operations to import a file, download the PDFs, and returns the number of errors encountered.

        Args:
            file_in (str, optional): The input file path. Defaults to None.
            destination (str, optional): The destination folder path. Defaults to None.
            max_downloads (int, optional): The maximum number of PDFs to download. Defaults to None.
            not_downloaded_files (str, optional): The file path to store the list of not downloaded files. Defaults to None.

        Returns:
            int: The number of errors encountered during the process.
        &#34;&#34;&#34;
        # Initialize the errors counter
        errors = 0
        if file_in is not None:
            self.file_in = file_in
        if destination is not None:
            self.destination = destination
        if max_downloads is not None:
            self.max_downloads = max_downloads
        if not_downloaded_files is not None:
            self.not_downloaded_files = not_downloaded_files
        # Initialize the lists
        errors += self.import_file()
        # Check the errors
        if errors == 0:
            # Download the PDFs
            errors += self.download_all()
        # Return the number of errors
        return errors
    
    def run(self) -&gt; None:
        &#34;&#34;&#34;
        Executes the do_all method as thread.
        &#34;&#34;&#34;
        self.do_all()

    @staticmethod
    def count_digits(n) -&gt; int:
        &#34;&#34;&#34;
        Count the number of digits in a given number.

        Args:
            n: The number to count the digits of.

        Returns:
            int: The number of digits in the given number.
        &#34;&#34;&#34;
        ns = str(n)
        return len(ns)</code></pre>
</details>
<div class="desc"><p>EUgolino is a class which allow to download PDF files from a list of URLs.</p>
<p>It was specifically designed to download papers from the European Union DataBase.
As the Conte Ugolino in Dante's Inferno, it is a greedy downloader.
As Ugolino della Gherardesca eats from the head of his enemy,
EUgolino feeds himself with the knowledge of scientific papers.</p>
<p>Initializes an instance of the EUgolino class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_in</code></strong> :&ensp;<code>str</code></dt>
<dd>The input file.</dd>
<dt><strong><code>candidates</code></strong> :&ensp;<code>list[<a title="EUgolino.classes.cocito.eugolino.DownloadCandidate" href="#EUgolino.classes.cocito.eugolino.DownloadCandidate">DownloadCandidate</a>]</code>, optional</dt>
<dd>List of download candidates. Defaults to None.</dd>
<dt><strong><code>max_downloads</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of downloads. Defaults to None.</dd>
<dt><strong><code>starting_point</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Starting point for the download. Defaults to 0.</dd>
<dt><strong><code>destination</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Destination directory for downloaded files. Defaults to None.</dd>
<dt><strong><code>not_downloaded_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>File to store the list of files that were not downloaded. Defaults to None.</dd>
<dt><strong><code>output</code></strong> :&ensp;<code>LogManager</code>, optional</dt>
<dd>LogManager instance for logging. Defaults to None.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>threading.Thread</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="EUgolino.classes.cocito.eugolino.EUgolino.candidates"><code class="name">var <span class="ident">candidates</span> : list[<a title="EUgolino.classes.cocito.eugolino.DownloadCandidate" href="#EUgolino.classes.cocito.eugolino.DownloadCandidate">DownloadCandidate</a>]</code></dt>
<dd>
<div class="desc"><p>List of download candidates.</p></div>
</dd>
<dt id="EUgolino.classes.cocito.eugolino.EUgolino.current"><code class="name">var <span class="ident">current</span> : <a title="EUgolino.classes.cocito.eugolino.DownloadCandidate" href="#EUgolino.classes.cocito.eugolino.DownloadCandidate">DownloadCandidate</a></code></dt>
<dd>
<div class="desc"><p>Current download candidate.</p></div>
</dd>
<dt id="EUgolino.classes.cocito.eugolino.EUgolino.destination"><code class="name">var <span class="ident">destination</span> : str</code></dt>
<dd>
<div class="desc"><p>Destination folder for downloaded files.</p></div>
</dd>
<dt id="EUgolino.classes.cocito.eugolino.EUgolino.downloaded"><code class="name">var <span class="ident">downloaded</span> : int</code></dt>
<dd>
<div class="desc"><p>Number of downloaded files.</p></div>
</dd>
<dt id="EUgolino.classes.cocito.eugolino.EUgolino.file_in"><code class="name">var <span class="ident">file_in</span> : str</code></dt>
<dd>
<div class="desc"><p>Input file containing the list of URLs.</p></div>
</dd>
<dt id="EUgolino.classes.cocito.eugolino.EUgolino.max_downloads"><code class="name">var <span class="ident">max_downloads</span> : int</code></dt>
<dd>
<div class="desc"><p>Maximum number of downloads.</p></div>
</dd>
<dt id="EUgolino.classes.cocito.eugolino.EUgolino.not_downloaded_files"><code class="name">var <span class="ident">not_downloaded_files</span> : str</code></dt>
<dd>
<div class="desc"><p>File to store the list of files that were not downloaded.</p></div>
</dd>
<dt id="EUgolino.classes.cocito.eugolino.EUgolino.output"><code class="name">var <span class="ident">output</span> : classes.log_manager.LogManager</code></dt>
<dd>
<div class="desc"><p>Log Manager for logging.</p></div>
</dd>
<dt id="EUgolino.classes.cocito.eugolino.EUgolino.starting_point"><code class="name">var <span class="ident">starting_point</span> : int</code></dt>
<dd>
<div class="desc"><p>Starting point for the download.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="EUgolino.classes.cocito.eugolino.EUgolino.count_digits"><code class="name flex">
<span>def <span class="ident">count_digits</span></span>(<span>n) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def count_digits(n) -&gt; int:
    &#34;&#34;&#34;
    Count the number of digits in a given number.

    Args:
        n: The number to count the digits of.

    Returns:
        int: The number of digits in the given number.
    &#34;&#34;&#34;
    ns = str(n)
    return len(ns)</code></pre>
</details>
<div class="desc"><p>Count the number of digits in a given number.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n</code></strong></dt>
<dd>The number to count the digits of.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The number of digits in the given number.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="EUgolino.classes.cocito.eugolino.EUgolino.do_all"><code class="name flex">
<span>def <span class="ident">do_all</span></span>(<span>self,<br>file_in: str = None,<br>destination: str = None,<br>max_downloads: int = None,<br>not_downloaded_files: str = None) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_all(self, file_in:str = None, destination:str = None, max_downloads:int = None, not_downloaded_files:str = None) -&gt; int:
    &#34;&#34;&#34;
    Performs all the necessary operations to import a file, download the PDFs, and returns the number of errors encountered.

    Args:
        file_in (str, optional): The input file path. Defaults to None.
        destination (str, optional): The destination folder path. Defaults to None.
        max_downloads (int, optional): The maximum number of PDFs to download. Defaults to None.
        not_downloaded_files (str, optional): The file path to store the list of not downloaded files. Defaults to None.

    Returns:
        int: The number of errors encountered during the process.
    &#34;&#34;&#34;
    # Initialize the errors counter
    errors = 0
    if file_in is not None:
        self.file_in = file_in
    if destination is not None:
        self.destination = destination
    if max_downloads is not None:
        self.max_downloads = max_downloads
    if not_downloaded_files is not None:
        self.not_downloaded_files = not_downloaded_files
    # Initialize the lists
    errors += self.import_file()
    # Check the errors
    if errors == 0:
        # Download the PDFs
        errors += self.download_all()
    # Return the number of errors
    return errors</code></pre>
</details>
<div class="desc"><p>Performs all the necessary operations to import a file, download the PDFs, and returns the number of errors encountered.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_in</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The input file path. Defaults to None.</dd>
<dt><strong><code>destination</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The destination folder path. Defaults to None.</dd>
<dt><strong><code>max_downloads</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The maximum number of PDFs to download. Defaults to None.</dd>
<dt><strong><code>not_downloaded_files</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The file path to store the list of not downloaded files. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The number of errors encountered during the process.</dd>
</dl></div>
</dd>
<dt id="EUgolino.classes.cocito.eugolino.EUgolino.downloadPDF"><code class="name flex">
<span>def <span class="ident">downloadPDF</span></span>(<span>self,<br>candidate: <a title="EUgolino.classes.cocito.eugolino.DownloadCandidate" href="#EUgolino.classes.cocito.eugolino.DownloadCandidate">DownloadCandidate</a> = None,<br>destination: str = None,<br>not_downloaded_file=None) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def downloadPDF(self, candidate: DownloadCandidate = None, destination:str = None, not_downloaded_file = None) -&gt; bool:
    &#34;&#34;&#34;
    Downloads a PDF file from a given URL and saves it to the specified destination.

    Args:
        candidate (DownloadCandidate, optional): The download candidate object containing the URL and filename. If not provided, the current candidate will be used. Defaults to None.
        destination (str, optional): The destination directory where the PDF file will be saved. If not provided, the default destination will be used. Defaults to None.
        not_downloaded_file (str, optional): The file path to the log file where the details of the not downloaded files will be recorded. If not provided, the default log file will be used. Defaults to None.

    Returns:
        bool: True if the PDF file was successfully downloaded and saved, False otherwise.
    &#34;&#34;&#34;
    if candidate is not None:
        self.current = candidate
    if destination is not None:  
        self.destination = destination
    if not_downloaded_file is not None:
        self.not_downloaded_files = not_downloaded_file
    full_path = self.destination + self.current.filename
    try:
        # Get the page
        dat = requests.get(url=self.current.url)
        # Get the cookies
        cookies = dat.cookies
        # Parse the page
        soup = BeautifulSoup(dat.text, &#39;html.parser&#39;)
        # Get the script tags
        link = soup.find_all(&#34;script&#34;)
        # Find the link to the pdf
        doc = &#34;&#34;
        # Search for the link
        for l in link:
            # Check if the script tag contains the link to the pdf
            if &#34;window.location&#34; in l.text:
                # Split the script tag to get the link
                s = l.text.split(&#34;\&#39;&#34;)
                # Get the link
                doc = s[3]
        # Download the pdf
        dat = requests.get(url=doc, cookies=cookies)
        # Save the pdf
        with open(full_path, &#34;wb&#34;) as f:
            f.write(dat.content)
        f.close()
        # Update the downloaded counter
        self.downloaded += 1
        # ACK message
        self.output.print_out(&#34;Downloaded\t&#34; + full_path)
        return True
    except:
        self.output.print_err(&#34;Error\t&#34; + full_path + &#34;\tnot downloaded&#34;)
        try:
            # Save the not downloaded file
            with open(self.not_downloaded_files, &#34;a&#34;) as f:
                f.write(self.current.print_candidate() + &#34;\n&#34;)
            f.close()
            # Update the input file
            self.file_in = self.not_downloaded_files
        except:
            self.output.print_err(&#34;Error\t&#34; + self.not_downloaded_files + &#34;\tnot updated&#34;)
        self.output.print_out(&#34;FAIL\t\t&#34; + full_path)
        return False</code></pre>
</details>
<div class="desc"><p>Downloads a PDF file from a given URL and saves it to the specified destination.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>candidate</code></strong> :&ensp;<code><a title="EUgolino.classes.cocito.eugolino.DownloadCandidate" href="#EUgolino.classes.cocito.eugolino.DownloadCandidate">DownloadCandidate</a></code>, optional</dt>
<dd>The download candidate object containing the URL and filename. If not provided, the current candidate will be used. Defaults to None.</dd>
<dt><strong><code>destination</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The destination directory where the PDF file will be saved. If not provided, the default destination will be used. Defaults to None.</dd>
<dt><strong><code>not_downloaded_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The file path to the log file where the details of the not downloaded files will be recorded. If not provided, the default log file will be used. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the PDF file was successfully downloaded and saved, False otherwise.</dd>
</dl></div>
</dd>
<dt id="EUgolino.classes.cocito.eugolino.EUgolino.download_all"><code class="name flex">
<span>def <span class="ident">download_all</span></span>(<span>self,<br>candidates: list[<a title="EUgolino.classes.cocito.eugolino.DownloadCandidate" href="#EUgolino.classes.cocito.eugolino.DownloadCandidate">DownloadCandidate</a>] = None,<br>destination: str = None,<br>max_downloads: int = None,<br>starting_point: int = None,<br>not_downloaded_files: str = None) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download_all(self, candidates: list[DownloadCandidate] = None, destination:str = None, max_downloads:int = None, starting_point:int = None, not_downloaded_files:str = None) -&gt; int:
    &#34;&#34;&#34;
    Downloads all the PDF files from the given list of download candidates.

    Args:
        candidates (list[DownloadCandidate], optional): List of DownloadCandidate objects representing the PDF files to download. If not provided, the previously set candidates will be used. Defaults to None.
        destination (str, optional): The destination folder where the downloaded PDF files will be saved. If not provided, the previously set destination will be used. Defaults to None.
        max_downloads (int, optional): The maximum number of PDF files to download. If not provided, all the candidates will be downloaded. Defaults to None.
        starting_point (int, optional): The starting point for the download. If not provided, the previously set starting point will be used. Defaults to None.
        not_downloaded_files (str, optional): The file path to save the list of files that were not downloaded. If not provided, the previously set file path will be used. Defaults to None.

    Returns:
        int: The number of errors that occurred during the download process.
    &#34;&#34;&#34;
    if candidates is not None:
        self.candidates = candidates
    if destination is not None:
        self.destination = destination
    if max_downloads is not None:   
        self.max_downloads = max_downloads
    if not_downloaded_files is not None:
        self.not_downloaded_files = not_downloaded_files
    if starting_point is not None:
        if self.max_downloads &lt; 0 or starting_point &lt; self.max_downloads:
            self.starting_point = starting_point

    # Initialize the errors counter
    errors = 0

    # Create the destination folder
    os.makedirs(self.destination, exist_ok=True)

    # Get the number of downloads
    num = self.candidates.__len__()

    # Check if the number of downloads is limited
    if self.max_downloads &gt; 0:
        # Limit the number of downloads
        num = min(num, self.max_downloads)

    # Get the number of digits of the length
    fi = self.count_digits(num)
    # Discard the first candidates
    self.candidates = self.candidates[self.starting_point:]
    # Download the PDFs
    for i in range(self.starting_point, num):
        # Get the filename
        self.current = self.candidates.pop(0)

        # Print the progress
        self.output.print_out(&#34;[&#34; + &#34;{:{}}&#34;.format((i+1), fi) + &#39;/&#39; + str(num) + &#34;]:&#34;, end=&#34;\t&#34;)

        # Download the PDF
        if not self.downloadPDF():
            # Update the errors counter
            errors += 1
            # Add the not downloaded file to the list of candidates
            self.candidates.append(self.current)

    return errors</code></pre>
</details>
<div class="desc"><p>Downloads all the PDF files from the given list of download candidates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>candidates</code></strong> :&ensp;<code>list[<a title="EUgolino.classes.cocito.eugolino.DownloadCandidate" href="#EUgolino.classes.cocito.eugolino.DownloadCandidate">DownloadCandidate</a>]</code>, optional</dt>
<dd>List of DownloadCandidate objects representing the PDF files to download. If not provided, the previously set candidates will be used. Defaults to None.</dd>
<dt><strong><code>destination</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The destination folder where the downloaded PDF files will be saved. If not provided, the previously set destination will be used. Defaults to None.</dd>
<dt><strong><code>max_downloads</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The maximum number of PDF files to download. If not provided, all the candidates will be downloaded. Defaults to None.</dd>
<dt><strong><code>starting_point</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The starting point for the download. If not provided, the previously set starting point will be used. Defaults to None.</dd>
<dt><strong><code>not_downloaded_files</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The file path to save the list of files that were not downloaded. If not provided, the previously set file path will be used. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The number of errors that occurred during the download process.</dd>
</dl></div>
</dd>
<dt id="EUgolino.classes.cocito.eugolino.EUgolino.import_file"><code class="name flex">
<span>def <span class="ident">import_file</span></span>(<span>self,<br>file: str = None,<br>candites: list[<a title="EUgolino.classes.cocito.eugolino.DownloadCandidate" href="#EUgolino.classes.cocito.eugolino.DownloadCandidate">DownloadCandidate</a>] = None) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_file(self, file:str = None, candites: list[DownloadCandidate] = None) -&gt; int:
    &#34;&#34;&#34;
    Imports a file and processes its contents to create download candidates.

    Args:
        file (str, optional): The path of the file to import. Defaults to None.
        candites (list[DownloadCandidate], optional): The list of existing download candidates. Defaults to None.

    Returns:
        int: The number of errors encountered during the import process.
    &#34;&#34;&#34;
    if file is not None:
        self.file_in = file
    if candites is not None:
        self.candidates = candites
    # Initialize the errors counter
    errors = 0
    # Initialize the candidate
    candite: DownloadCandidate = None
    try:
        # Open the file
        with open(self.file_in, &#39;r&#39;) as f:
            # Read the file line by line
            self.output.print_out(&#34;Importing file: &#34; + self.file_in)
            # Process each line
            for line in f:
                # Create a candidate
                candite = DownloadCandidate.make_candidate(line)
                # Check if the candidate is not None
                if candite is not None:
                    # Add the candidate to the list
                    self.candidates.append(candite)
                else:
                    errors += 1
        f.close()
        # ACK message
        self.output.print_out(&#34;File imported&#34;)
    except:
        self.output.print_err(&#34;Error: file\t&#34; + self.file_in + &#34;\tnot imported&#34;)
        errors = -1
    # If the current candidate is None, set it to the first candidate
    if self.candidates != [] and self.current is None:
        self.current = self.candidates[0]
    # Return the number of errors
    return errors</code></pre>
</details>
<div class="desc"><p>Imports a file and processes its contents to create download candidates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The path of the file to import. Defaults to None.</dd>
<dt><strong><code>candites</code></strong> :&ensp;<code>list[<a title="EUgolino.classes.cocito.eugolino.DownloadCandidate" href="#EUgolino.classes.cocito.eugolino.DownloadCandidate">DownloadCandidate</a>]</code>, optional</dt>
<dd>The list of existing download candidates. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The number of errors encountered during the import process.</dd>
</dl></div>
</dd>
<dt id="EUgolino.classes.cocito.eugolino.EUgolino.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self) -&gt; None:
    &#34;&#34;&#34;
    Executes the do_all method as thread.
    &#34;&#34;&#34;
    self.do_all()</code></pre>
</details>
<div class="desc"><p>Executes the do_all method as thread.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="EUgolino.classes.cocito" href="index.html">EUgolino.classes.cocito</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="EUgolino.classes.cocito.eugolino.DownloadCandidate" href="#EUgolino.classes.cocito.eugolino.DownloadCandidate">DownloadCandidate</a></code></h4>
<ul class="">
<li><code><a title="EUgolino.classes.cocito.eugolino.DownloadCandidate.filename" href="#EUgolino.classes.cocito.eugolino.DownloadCandidate.filename">filename</a></code></li>
<li><code><a title="EUgolino.classes.cocito.eugolino.DownloadCandidate.make_candidate" href="#EUgolino.classes.cocito.eugolino.DownloadCandidate.make_candidate">make_candidate</a></code></li>
<li><code><a title="EUgolino.classes.cocito.eugolino.DownloadCandidate.name" href="#EUgolino.classes.cocito.eugolino.DownloadCandidate.name">name</a></code></li>
<li><code><a title="EUgolino.classes.cocito.eugolino.DownloadCandidate.print_candidate" href="#EUgolino.classes.cocito.eugolino.DownloadCandidate.print_candidate">print_candidate</a></code></li>
<li><code><a title="EUgolino.classes.cocito.eugolino.DownloadCandidate.url" href="#EUgolino.classes.cocito.eugolino.DownloadCandidate.url">url</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="EUgolino.classes.cocito.eugolino.EUgolino" href="#EUgolino.classes.cocito.eugolino.EUgolino">EUgolino</a></code></h4>
<ul class="">
<li><code><a title="EUgolino.classes.cocito.eugolino.EUgolino.candidates" href="#EUgolino.classes.cocito.eugolino.EUgolino.candidates">candidates</a></code></li>
<li><code><a title="EUgolino.classes.cocito.eugolino.EUgolino.count_digits" href="#EUgolino.classes.cocito.eugolino.EUgolino.count_digits">count_digits</a></code></li>
<li><code><a title="EUgolino.classes.cocito.eugolino.EUgolino.current" href="#EUgolino.classes.cocito.eugolino.EUgolino.current">current</a></code></li>
<li><code><a title="EUgolino.classes.cocito.eugolino.EUgolino.destination" href="#EUgolino.classes.cocito.eugolino.EUgolino.destination">destination</a></code></li>
<li><code><a title="EUgolino.classes.cocito.eugolino.EUgolino.do_all" href="#EUgolino.classes.cocito.eugolino.EUgolino.do_all">do_all</a></code></li>
<li><code><a title="EUgolino.classes.cocito.eugolino.EUgolino.downloadPDF" href="#EUgolino.classes.cocito.eugolino.EUgolino.downloadPDF">downloadPDF</a></code></li>
<li><code><a title="EUgolino.classes.cocito.eugolino.EUgolino.download_all" href="#EUgolino.classes.cocito.eugolino.EUgolino.download_all">download_all</a></code></li>
<li><code><a title="EUgolino.classes.cocito.eugolino.EUgolino.downloaded" href="#EUgolino.classes.cocito.eugolino.EUgolino.downloaded">downloaded</a></code></li>
<li><code><a title="EUgolino.classes.cocito.eugolino.EUgolino.file_in" href="#EUgolino.classes.cocito.eugolino.EUgolino.file_in">file_in</a></code></li>
<li><code><a title="EUgolino.classes.cocito.eugolino.EUgolino.import_file" href="#EUgolino.classes.cocito.eugolino.EUgolino.import_file">import_file</a></code></li>
<li><code><a title="EUgolino.classes.cocito.eugolino.EUgolino.max_downloads" href="#EUgolino.classes.cocito.eugolino.EUgolino.max_downloads">max_downloads</a></code></li>
<li><code><a title="EUgolino.classes.cocito.eugolino.EUgolino.not_downloaded_files" href="#EUgolino.classes.cocito.eugolino.EUgolino.not_downloaded_files">not_downloaded_files</a></code></li>
<li><code><a title="EUgolino.classes.cocito.eugolino.EUgolino.output" href="#EUgolino.classes.cocito.eugolino.EUgolino.output">output</a></code></li>
<li><code><a title="EUgolino.classes.cocito.eugolino.EUgolino.run" href="#EUgolino.classes.cocito.eugolino.EUgolino.run">run</a></code></li>
<li><code><a title="EUgolino.classes.cocito.eugolino.EUgolino.starting_point" href="#EUgolino.classes.cocito.eugolino.EUgolino.starting_point">starting_point</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
